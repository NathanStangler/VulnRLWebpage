<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html lang=" en-US">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>NLP Class Project | Fall 2025 CSCI 5541 | University of Minnesota</title>

  <link rel="stylesheet" href="./files/bulma.min.css" />
  <link rel="stylesheet" href="./files/styles.css">
  <link rel="preconnect" href="https://fonts.gstatic.com/">
  <link href="./files/css2" rel="stylesheet">
  <link href="./files/css" rel="stylesheet">

  <base href="." target="_blank">
</head>

<body>
  <div>
    <div class="wrapper">
      <h1 style="font-family: 'Lato', sans-serif;">Compiler-Verified RL for Code Vulnerability Detection</h1>
      <h4 style="font-family: 'Lato', sans-serif;">Fall 2025 CSCI 5541 NLP: Class Project - University of Minnesota</h4>
      <h4 style="font-family: 'Lato', sans-serif;">Embedding Squad</h4>

      <div class="authors-wrapper">
        <div class="author-container">
          <p>Nathan Stangler</p>
        </div>
        
        <div class="author-container">
          <p>Tamojit Bera</p>
        </div>
        
        <div class="author-container">
          <p>Aryan Jaiswal</p>
        </div>
      </div>

      <br/>

      <div class="authors-wrapper">
        <div class="publication-links">
          <span class="link-block">
            <a
              href="https://github.com/NathanStangler/VulnRL"
              target="_blank"
              class="external-link button is-normal is-rounded is-dark is-outlined"
            >
              <span>Code</span>
            </a>
          </span>  
        </div>
      </div>
    </div>
  </div>

  <div class="wrapper">
    <hr>
    
    <h2 id="abstract">Abstract</h2>

    <p>
      Software vulnerabilities remain a critical threat to modern computing infrastructures. Traditional vulnerability detection tools suffer from limited generalization, inconsistent coverage, and high false-positive rates due to their reliance on handcrafted patterns or narrow static analysis. We propose <b>VulnRL</b>, a compiler-verified reinforcement learning framework for automated vulnerability detection in source code. Our approach leverages compiler feedback---including diagnostic errors, static analyzer reports, and sanitizer outputs---as structured reward signals that refine model behavior beyond what static dataset supervision provides. The system integrates parameter-efficient fine-tuning (PEFT) with an additional reinforcement learning stage to achieve more robust representations of vulnerability semantics across Common Weakness Enumeration (CWE) categories. Additionally, we introduce an interactive web interface designed to facilitate practical evaluation and real-time inspection of model predictions and compiler signals. Our experiments demonstrate the effectiveness of PEFT fine-tuning, and we present methodology and observations for compiler-verified reinforcement learning.
    </p>

    <hr>

    <h2 id="teaser">Compiler-Verified Reinforcement Learning</h2>

    <p class="sys-img"><img src="./files/diagram.png" alt="RL Figure"></p>

    <p>
      Source code samples are fed into a fine-tuned coder model that predicts vulnerabilities. The model receives feedback from
      the compiler and analyzers&mdash;such as Clang diagnostics, <code>clang-tidy</code> security warnings, and sanitizer crashes&mdash;which are
      converted into reward signals to refine its predictions via reinforcement learning.
    </p>

    <hr>

    <h2 id="introduction">Introduction / Background / Motivation</h2>
    <p>
Safe software engineering relies heavily on automated tooling to detect vulnerabilities before they reach production systems. The prevalence of memory-related vulnerabilities in C and C++ programs---such as buffer overflows, use-after-free errors, and improper pointer arithmetic---demonstrates the need for improved detection approaches.

Traditional static analyzers inspect code using rule-based patterns derived from programming language semantics. These tools are fast but brittle: they often fail to generalize to new vulnerability variants and warn frequently about benign code, causing alert fatigue among developers. Meanwhile, machine learning models trained on labeled datasets often conflate stylistic variations with semantic differences, and the labels themselves are limited by human annotation quality.

In contrast, compiler infrastructures can identify concrete behavioral issues such as undefined behavior, out-of-bounds accesses, and dangerous memory operations. Our key insight is that compilers already act as structured vulnerability detectors, even though their outputs are not typically used to train machine learning systems. VulnRL leverages these signals to create a model that learns the semantic structure of vulnerabilities.
    </p>

    <p>
Our objective is to develop a vulnerability detection model that learns what makes code unsafe not merely from labeled examples, but from how compilers interpret and analyze the structure and behavior of programs.

Traditional approaches treat detection as a simple supervised classification problem. However, the mapping from code to vulnerability labels is highly context-dependent and influenced by subtle interactions that static datasets do not capture. Many vulnerabilities manifest only at runtime, making compiler feedback---especially sanitizer outputs---a valuable source of supervision.
    </p>

    <p>
A system capable of learning from compiler diagnostics would have significant implications for both research and practice. It could:
    </p>
    <ul>
      <li>improve early identification of subtle vulnerabilities,</li>
      <li>reduce the cognitive load on developers by filtering out false positives,</li>
      <li>provide security insights grounded in behavioral rather than purely syntactic cues,</li>
      <li>support automated auditing of legacy codebases.</li>
    </ul>
    <p>
      Such a system could complement static analysis and symbolic execution, offering a new dimension in vulnerability detection.
    </p>

    <hr>

    <h2 id="approach">Approach</h2>
    <p>
      Our system, VulnRL, has four main components:
    </p>
    <ol>
      <li><b>Dataset processing:</b> We ingest C++ vulnerability datasets (Lemon42, MegaVul, SecVulEval), clean labels, and chunk
          long files into function-level units using LlamaIndex's code splitters so they fit into the model context.</li>
      <li><b>Supervised fine-tuning:</b> We apply LoRA-based parameter-efficient fine-tuning (PEFT) to large code models such as
          Qwen 2.5 Coder and DeepSeek Coder. This step trains the model to predict CWE-style labels (or <code>safe</code>) from code snippets.</li>
      <li><b>Compiler-verified reinforcement learning:</b> Starting from the finetuned model, we run an RL loop where the model
          predicts a label, we compile the code, collect diagnostics and sanitizer signals, and convert them into a scalar reward.</li>
      <li><b>Interactive web interface:</b> A FastAPI backend and simple frontend let users upload code, choose a model, and view
          predictions alongside compiler warnings and sanitizer traces.</li>
    </ol>

    <p>
      The key novelty is in step (3): we do not just train on labels; we train on how the compiler and security tools react to
      the code. For each snippet, the model picks a label. We then:
    </p>
    <ul>
      <li>write the snippet to a temporary <code>.cpp</code> file,</li>
      <li>run Clang, <code>clang-tidy</code>, and sanitizers,</li>
      <li>parse diagnostics into a <i>compiler reward</i> (more and more severe warnings = lower reward),</li>
      <li>optionally add a <i>classification reward</i> if the label matches the gold CWE label.</li>
    </ul>
    <p>
      The final reward is a weighted mix of compiler reward and label agreement. This prevents the model from drifting too far
      away from the dataset while still letting the compiler signals move the decision boundary.
    </p>

    <p>
      We anticipated three main issues:
    </p>
    <ul>
      <li><b>Long code snippets:</b> Large files may not fit into the context window. We handled this by chunking files into
          logical units (functions, classes) while keeping metadata so we can trace predictions back to source files.</li>
      <li><b>Weak or noisy rewards:</b> We worried that compilers might not give enough information. The reality was the opposite:
          static analyzers tend to over-predict potential issues, so many snippets looked "bad" even when they were not actually
          vulnerable.</li>
      <li><b>Instability in RL training:</b> With raw compiler scores, rewards were often very negative and skewed. Early RL runs
          drove the model to mark almost everything as unsafe. This pushed us to add the label-based reward term, clip rewards,
          and use a moving baseline.</li>
    </ul>
    <p>
      The first naive attempt&mdash;using only compiler-derived reward&mdash;did not work well. The model learned that "everything is
      vulnerable" is a safe bet. After reward shaping and mixing in label correctness, we were able to get RL runs that improved
      performance on at least one dataset over the finetuned baseline.
    </p>

    <hr>
        
    <h2 id="results">Results</h2>
    <p>
We train and evaluate on Lemon42, MegaVul, and SecVulEval, representing varying code styles, lengths, and vulnerability categories. The vulnerable code is a mix between well designed manual examples and real-world vulnerabilities scraped from GitHub. The datasets are each split into train and test sets, which are combined into one train/test split. Metrics include multi-class accuracy, F1, and binary safe/unsafe accuracy. For each model, we report three settings:
    </p>
    <ul>
      <li><b>Baseline:</b> zero-shot predictions from the pretrained model.</li>
      <li><b>Finetuned:</b> LoRA-based PEFT supervised on the union of train datasets.</li>
      <li><b>Reinforced:</b> finetuned model further refined with compiler-verified RL.</li>
    </ul>

    <table id="model_results" style="width:100%;border-collapse:collapse;">
      <caption style="caption-side:bottom;text-align:left;padding:6px 0;">Evaluation results across models, training types, and datasets.</caption>
      <thead>
        <tr>
          <th style="border:1px solid #ddd;padding:6px;text-align:center;">Model</th>
          <th style="border:1px solid #ddd;padding:6px;text-align:center;">Type</th>
          <th colspan="3" style="border:1px solid #ddd;padding:6px;text-align:center;">Lemon42</th>
          <th colspan="3" style="border:1px solid #ddd;padding:6px;text-align:center;">MegaVul</th>
          <th colspan="3" style="border:1px solid #ddd;padding:6px;text-align:center;">SecVulEval</th>
        </tr>
        <tr>
          <th style="border:1px solid #ddd;padding:6px;"></th>
          <th style="border:1px solid #ddd;padding:6px;"></th>
          <th style="border:1px solid #ddd;padding:6px;text-align:center;">Acc</th>
          <th style="border:1px solid #ddd;padding:6px;text-align:center;">F1</th>
          <th style="border:1px solid #ddd;padding:6px;text-align:center;">Binary Acc</th>
          <th style="border:1px solid #ddd;padding:6px;text-align:center;">Acc</th>
          <th style="border:1px solid #ddd;padding:6px;text-align:center;">F1</th>
          <th style="border:1px solid #ddd;padding:6px;text-align:center;">Binary Acc</th>
          <th style="border:1px solid #ddd;padding:6px;text-align:center;">Acc</th>
          <th style="border:1px solid #ddd;padding:6px;text-align:center;">F1</th>
          <th style="border:1px solid #ddd;padding:6px;text-align:center;">Binary Acc</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td rowspan="3" style="border:1px solid #ddd;padding:6px;vertical-align:middle;">Qwen 2.5 Coder 1.5B Instruct</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">Baseline</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0658</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0991</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4342</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1056</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0378</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">1.0000</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0511</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0093</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.3194</td>
        </tr>
        <tr>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">Finetuned</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5921</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5921</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.6053</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1254</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0993</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.7195</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.2486</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.3033</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4316</td>
        </tr>
        <tr>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">Reinforced</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5000</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4460</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5132</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1617</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1351</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.7624</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.2081</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.2613</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4181</td>
        </tr>

        <tr>
          <td rowspan="3" style="border:1px solid #ddd;padding:6px;vertical-align:middle;">DeepSeek Coder 6.7B Instruct</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">Baseline</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4605</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4960</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5395</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0099</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0148</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0858</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.6252</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5350</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.6435</td>
        </tr>
        <tr>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">Finetuned</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4605</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5253</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5789</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1155</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0414</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.9010</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0850</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1246</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.3550</td>
        </tr>
        <tr>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">Reinforced</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5000</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4019</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5921</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1800</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0916</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.9000</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1300</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.2083</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4000</td>
        </tr>

        <tr>
          <td rowspan="3" style="border:1px solid #ddd;padding:6px;vertical-align:middle;">Qwen 2.5 Coder 7B Instruct</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">Baseline</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.3816</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.3626</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5000</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0297</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.0295</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.2739</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5279</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4925</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.5896</td>
        </tr>
        <tr>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">Finetuned</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.8289</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.8299</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.8553</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1386</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1262</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.7657</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.2750</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.3338</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4475</td>
        </tr>
        <tr>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">Reinforced</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.8289</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.8299</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.8553</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1551</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.1447</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.7657</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.2746</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.3318</td>
          <td style="border:1px solid #ddd;padding:6px;text-align:center;">0.4436</td>
        </tr>
      </tbody>
    </table>

    <p>
Finetuning substantially improves performance over the baseline in most settings, especially on Lemon42 and SecVulEval. For example, Qwen 2.5 Coder 7B jumps from 0.3816 to 0.8289 accuracy on Lemon42, and binary safe/unsafe accuracy rises from 0.5000 to 0.8553. This suggests that large code models contain useful general knowledge about program structure,but targeted CWE-supervised fine-tuning is essential for precise vulnerability classification.

On MegaVul, the gains are more modest. Both Qwen and DeepSeek see only small improvements in multi-class accuracy, even though binary safe/unsafe accuracy increases. This is consistent with the dataset being more challenging and skewed, with many subtle vulnerabilities and imbalanced CWE classes. Additionally, MegaVul captures lower-level coding vulnerabilities such as those involving operating system architecture (Linux).
    </p>

    <p>
For the MegaVul, RL improves over the finetuned model on selected metrics, indicating that compiler feedback can correct some residual misclassifications. On the other datasets, RL tends to move performance between the baseline and the finetuned model, performing better than zero-shot, but not uniformly better than supervised fine-tuning.

These trends are consistent with our expectations: RL is most helpful where compiler feedback strongly correlates with true vulnerabilities, and less helpful where diagnostics are noisy or ambiguous. The results correspond with earlier analysis--MegaVul consists of low-level code samples, which produce security tool detectable alerts.
    </p>

    <p>
      Qualitatively, RL tends to:
    </p>
    <ul>
      <li>make the model more confident and consistent on snippets where compiler warnings and labels agree,</li>
      <li>favor "unsafe" predictions when the analyzer is noisy, even on benign code,</li>
      <li>shift the distribution of CWE labels toward those that are commonly highlighted by <code>clang-tidy</code> and sanitizers.</li>
    </ul>

    <p>
      We also created a UI that allows users to interact with the model, view its outputs, and see feedback from compiler and
      analyzer tools. The UI makes it simple to upload a C++ file, choose a model (baseline, finetuned, RL), and inspect both the
      predicted label and the underlying diagnostics.
    </p>

    <img src="./files/ui.png" alt="UI Figure">

    <p>
The interactive UI has proven invaluable in identifying these cases and guiding refinements. Being able to visually inspect how a model's prediction changes after RL, alongside concrete compiler messages, provides a powerful debugging loop that would be difficult to replicate from aggregate metrics alone.
    </p>

    <hr>

    <h2 id="conclusion">Conclusion and Future Work</h2>

    <p>
      Our experiments show that compiler-verified reinforcement learning is a promising way to improve learned vulnerability
      detectors beyond what is achievable with supervised fine-tuning alone. The supervised PEFT stage provides a strong baseline
      on multiple datasets, and the RL stage can further refine behavior when compiler and analyzer feedback align with true
      vulnerabilities.
    </p>

    <p>
      <b>Reproducibility.</b> The pipeline is implemented with open-source datasets, standard compilers (Clang, <code>clang-tidy</code>, sanitizers),
      and configuration-driven training scripts. Different groups should be able to reproduce our qualitative trends, although exact
      numbers may vary due to hardware differences and minor nondeterminism in CUDA and compiler behavior.
    </p>

    <p>
      <b>Ethical considerations.</b> Any tool that automatically flags vulnerabilities carries risks:
    </p>
    <ul>
      <li>It can be misused to scan third-party code without permission.</li>
      <li>Developers may over-trust the model and miss issues it fails to detect.</li>
      <li>Biases in the datasets and security tools can be amplified by training.</li>
    </ul>
    <p>
      We recommend combining such models with human review, logging, and clear documentation, and treating VulnRL as a decision
      support tool rather than a final authority on security.
    </p>

    <p>
      <b>Limitations and future work.</b> Our current system:
    </p>
    <ul>
      <li>is limited to C++ and a small set of datasets,</li>
      <li>depends heavily on one toolchain (Clang + specific sanitizers),</li>
    </ul>
    <p>
      Future work includes refining the reward function to better match real vulnerabilities, using curriculum RL to stabilize
      training, scaling RL to larger models and multi-file projects, and extending the approach to other languages and security
      domains. We also plan to deepen the integration into developer workflows and CI pipelines so that compiler-verified RL can
      be evaluated in more realistic settings.
    </p>

    <hr>
  </div>
</body>
</html>
